Внимание! Мем:

![C4model](images/meme.jpg)

# Banner service

Сервис, который позволяет показывать пользователям баннеры, в зависимости от требуемой фичи и тега пользователя, а также управлять баннерами и связанными с ними тегами и фичами.

## Getting Started
Перед запуском сервиса нужно заполнить .env файл

Запуск сервиса:
```
docker-compose up
```
или
```
make run
```

Запуск e2e тестов:
```
make test
```

## Examples
* [Создание баннера](#Создание-баннера)
* [Получение баннера для пользователя](#Получение-баннера-для-пользователя)
* [Получение баннеров по фильтру](#Получение-баннеров-по-фильтру)
* [Обновить баннер](#Обновить-баннер)
* [История изменений баннера](#История-изменений-баннера)
* [Установить одну из предыдущих версий баннера](#Установить-одну-из-предыдущих-версий-баннера)
* [Удаление баннеров](#Удаление-баннеров)

### Создание баннера 
Пример запроса:
```
POST localhost:8080/banner/ HTTP/1.1
Content-Type: application/json
Authorization: admin_token

{
  "tag_ids": [1, 3, 4],
  "feature_id": 11,
  "content":  {"data": "some_data"},
  "is_active": true
}
```
Пример ответа:
```
{
    "banner_id": 3
}
```

### Получение баннера для пользователя
Пример запроса:
```
GET localhost:8080/user_banner/?tag_id=1&feature_id=11&use_last_revision=true HTTP/1.1
Authorization: user_token
```

Параметр use_last_revision можно опустить.


Пример ответа:
```
{
  "data": "some_data"
}
```

### Получение баннеров по фильтру 
Получение всех баннеров c фильтрацией по фиче и/или тегу. Также можно фильтровать по id баннера, указывать limit и offset.

Пример запроса 1 (без фильтров выводит все имеющиеся баннеры):
```
GET localhost:8080/banner/
Authorization: admin_token
```
Пример ответа:
```
[
  {
    "banner_id": 7,
    "tag_ids": [
      8,
      5
    ],
    "feature_id": 1,
    "content": {
      "text": "some_text",
      "title": "some_title",
      "url": "some_url"
    },
    "is_active": true,
    "created_at": "2024-04-13T22:27:26.12265Z",
    "updated_at": "2024-04-13T22:27:26.12265Z"
  },
  {
    "banner_id": 12,
    "tag_ids": [
      1,
      3,
      4
    ],
    "feature_id": 11,
    "content": {
      "data": "test_data"
    },
    "is_active": true,
    "created_at": "2024-04-14T16:30:57.832038Z",
    "updated_at": "2024-04-14T16:30:57.832038Z"
  }
]
```
Пример запроса 2 (по id баннера): 
```
GET localhost:8080/banner/?banner_id=10
Authorization: admin_token
```
Пример запроса 3 (по фиче, тегу, с лимитом и оффсетом):
```
GET localhost:8080/banner/?feature_id=11&tag_id=1&limit=1&offset=1
Authorization: admin_token
```

### Обновить баннер
Обновление баннера по его id.

Пример запроса:
```
PATCH localhost:8080/banner/7 HTTP/1.1
Content-Type: application/json
Authorization: admin_token

{
  "tag_ids": [1, 3, 4],
  "feature_id": 12,
  "content":  {"data": "some_data_patch"},
  "is_active": true
}
```
Пример ответа:
```
{
  "message": "ok"
}
```

### История изменений баннера
Показывает 3 предыдущие версии баннера по его id, если они существуют.

Пример запроса:
```
GET localhost:8080/banner_history/10 HTTP/1.1
Authorization: admin_token
```
Пример ответа:
```
{
  "banner_id": 10,
  "versions": [
    {
      "version": 3,
      "tag_ids": [
        1,
        3,
        4
      ],
      "feature_id": 12,
      "content": {
        "data": "test_data_patch3"
      },
      "is_active": true
    },
    {
      "version": 2,
      "tag_ids": [
        3
      ],
      "feature_id": 11,
      "content": {
        "data": "test_data_patch2"
      },
      "is_active": true
    },
    {
      "version": 1,
      "tag_ids": [
        1
      ],
      "feature_id": 11,
      "content": {
        "data": "test_data_patch1"
      },
      "is_active": true
    }
  ]
}
```

### Установить одну из предыдущих версий баннера
Устанавливает указанную версию конкретного баннера из истории. 
Номера версий и содержимое лучше заранее проверить через историю баннера.

Пример запроса:
```
POST localhost:8080/banner_history/10?set_version=2 HTTP/1.1
Authorization: admin_token
```
Пример ответа:
```
{
  "message": "ok"
}
```

### Удаление баннеров
Удалять можно по id баннера (путь /id/), по тегу (путь /tag/) или по фиче (путь /feature/).

Пример запроса 1 (по фиче):
```
DELETE localhost:8080/delete/feature/11 HTTP/1.1
Authorization: admin_token
```
Пример ответа:
```
{
  "message": "feature was added to deletion queue"
}
```
Пример запроса 2 (по тегу):
```
DELETE localhost:8080/delete/tag/1 HTTP/1.1
Authorization: admin_token
```
Пример запроса 3 (по id баннера):
```
DELETE localhost:8080/delete/id/5 HTTP/1.1
Authorization: admin_token
```


## Solutions
В процессе разработки были приняты решения:
1. Изменения в апи.
> При разработке немного отошла от описанного в задании апи. В фильтрацию баннеров добавила
> фильтр по айди баннера. Изменила хендлер удаления баннера по его айди (для возможности
> откладывания удаления).
2. Доп. задание: "Добавить метод удаления баннеров по фиче или тегу, время ответа которого не должно превышать 100 мс, независимо от количества баннеров."
> Хендлеры /delete/ добавляют данные в "очередь" (на самом деле просто массивы, 
> обернутые мьютексами), а отдельно работающая воркер-горутина раз в 10 секунд забирает 
> собранные данные и одним запросом к БД удаляет все необходимое. На значения в кеше стоит TTL 5 секунд.
> 
> Лучше было бы реализовать "очередь" с помощью брокеров сообщений, например, kafka, 
> но решила обойтись пока что без этого.
3. Доп. задание: "Адаптировать систему для значительного увеличения количества тегов и фичей, при котором допускается увеличение времени исполнения по редко запрашиваемым тегам и фичам."
> Реализовано кешированием данных в redis.
4. Токены.
> Реализовала хранение токенов крайне примитивно (прямо в хендлере). В идеале бы
> использовать сторонние сервисы. Считаю, что главнее было показать применение middleware-функций 
> для проверки соответствия токена.